htmlDownloadCopy code<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="dark" />
  <title>بوابة الشتاء • Enter</title>
  <style>
    :root{
      --bg0:#02030a;
      --bg1:#050818;
      --ice0:#0b1630;
      --ice1:#0aa9ff;
      --ice2:#d9fbff;
      --glass: rgba(12, 16, 30, .42);
      --glass2: rgba(255,255,255,.08);
      --stroke: rgba(255,255,255,.14);
      --text: rgba(245, 250, 255, .92);
      --muted: rgba(245, 250, 255, .62);
      --shadow: rgba(0,0,0,.55);
      --accent:#7de6ff;
      --accent2:#b6fff1;
      --danger:#ff5a7a;
      --ok:#6dffb1;
      --ring: rgba(125,230,255,.45);

      --parallaxX: 0px;
      --parallaxY: 0px;
      --tiltX: 0deg;
      --tiltY: 0deg;

      --ui-scale: 1;
    }

    *{ box-sizing: border-box; }
    html, body { height: 100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Noto Sans Arabic", "Noto Naskh Arabic", "Cairo", sans-serif;
      background: radial-gradient(1200px 800px at 50% 20%, #0a1233 0%, #040712 45%, #010208 100%);
      color: var(--text);
      overflow: hidden;
    }

    /* Subtle film grain */
    body::before{
      content:"";
      position:fixed; inset:-40%;
      background:
        radial-gradient(circle at 20% 10%, rgba(255,255,255,.05), transparent 55%),
        radial-gradient(circle at 80% 60%, rgba(255,255,255,.04), transparent 58%),
        repeating-linear-gradient(0deg, rgba(255,255,255,.02) 0 1px, transparent 1px 3px);
      filter: blur(0.6px) contrast(105%);
      opacity:.18;
      pointer-events:none;
      transform: rotate(9deg);
      mix-blend-mode: overlay;
      z-index: 50;
    }

    .app{
      position: relative;
      height: 100vh;
      width: 100vw;
      perspective: 1000px;
      transform-style: preserve-3d;
    }

    /* Base scene container */
    .scene{
      position:absolute; inset:0;
      transform-style: preserve-3d;
      background: radial-gradient(1200px 700px at 50% 15%, #0a1c45 0%, #05071a 52%, #010208 100%);
    }

    /* Optional user-provided background image (exact match) */
    .bgImage{
      position:absolute; inset:0;
      background-size: cover;
      background-position: center;
      background-repeat:no-repeat;
      opacity: 0;
      filter: saturate(1.05) contrast(1.06);
      transform: translate3d(calc(var(--parallaxX) * .06), calc(var(--parallaxY) * .06), -10px) scale(1.06);
      transition: opacity .35s ease;
    }
    .bgImage.on{ opacity: 1; }

    /* Procedural gradient fallback background */
    .bgProcedural{
      position:absolute; inset:0;
      background:
        radial-gradient(1100px 620px at 50% 15%, rgba(44,85,160,.55) 0%, rgba(10,18,51,.25) 32%, rgba(0,0,0,0) 62%),
        radial-gradient(900px 500px at 55% 35%, rgba(180,240,255,.15) 0%, transparent 55%),
        linear-gradient(to bottom, #05081a 0%, #02030a 45%, #02030a 100%);
      transform: translate3d(calc(var(--parallaxX) * .04), calc(var(--parallaxY) * .04), -40px) scale(1.08);
      filter: contrast(1.08) saturate(1.03);
    }

    /* Canvas layers */
    canvas.layer{
      position:absolute; inset:0;
      width:100%;
      height:100%;
      display:block;
      transform-style: preserve-3d;
      pointer-events:none;
    }
    #skyCanvas{
      transform: translate3d(calc(var(--parallaxX) * .02), calc(var(--parallaxY) * .02), -60px) scale(1.08);
      mix-blend-mode: screen;
      opacity: .95;
    }
    #snowCanvas{
      transform: translate3d(calc(var(--parallaxX) * .13), calc(var(--parallaxY) * .13), 60px);
      mix-blend-mode: screen;
      opacity: .95;
    }

    /* Faux depth: atmospheric haze + vignette */
    .atmo{
      position:absolute; inset:0;
      background:
        radial-gradient(900px 520px at 50% 62%, rgba(160, 230, 255, .08) 0%, rgba(6,8,16,0) 60%),
        radial-gradient(800px 420px at 50% 78%, rgba(150, 245, 255, .08) 0%, transparent 70%),
        radial-gradient(1200px 800px at 50% 80%, rgba(0,0,0,.35) 0%, rgba(0,0,0,.55) 55%, rgba(0,0,0,.86) 100%);
      pointer-events:none;
      transform: translate3d(0,0,120px);
      opacity: .98;
    }

    /* Foreground framing "trees" (stylized but photoreal-ish lighting) */
    .frame{
      position:absolute; inset:0;
      pointer-events:none;
      transform-style: preserve-3d;
      transform: translate3d(calc(var(--parallaxX) * .18), calc(var(--parallaxY) * .18), 110px) rotateX(var(--tiltX)) rotateY(var(--tiltY));
      filter: drop-shadow(0 18px 40px rgba(0,0,0,.55));
      opacity: .92;
    }

    .frame .left,
    .frame .right{
      position:absolute; top:-8%; bottom:-10%;
      width: 40vw;
      min-width: 260px;
      background-repeat:no-repeat;
      background-size: cover;
      mix-blend-mode: normal;
      opacity: .98;
    }
    .frame .left{
      left:-12vw;
      transform: rotate(-2deg) translateZ(0);
      background:
        radial-gradient(closest-side at 70% 20%, rgba(255,255,255,.28), transparent 70%),
        radial-gradient(closest-side at 64% 55%, rgba(255,255,255,.18), transparent 70%),
        radial-gradient(closest-side at 70% 80%, rgba(255,255,255,.22), transparent 72%),
        linear-gradient(90deg, rgba(0,0,0,.86) 0%, rgba(0,0,0,.72) 28%, rgba(0,0,0,0) 78%),
        radial-gradient(600px 900px at 30% 45%, rgba(40,60,80,.55), rgba(0,0,0,0) 70%),
        repeating-radial-gradient(circle at 35% 40%, rgba(255,255,255,.06) 0 2px, transparent 2px 10px);
      filter: blur(.2px) contrast(1.06) saturate(1.02);
      clip-path: polygon(0 0, 82% 0, 65% 14%, 88% 28%, 62% 42%, 84% 57%, 58% 72%, 80% 86%, 52% 100%, 0 100%);
    }
    .frame .right{
      right:-12vw;
      transform: rotate(2.2deg) translateZ(0);
      background:
        radial-gradient(closest-side at 35% 20%, rgba(255,255,255,.30), transparent 70%),
        radial-gradient(closest-side at 32% 52%, rgba(255,255,255,.18), transparent 70%),
        radial-gradient(closest-side at 35% 82%, rgba(255,255,255,.24), transparent 72%),
        linear-gradient(-90deg, rgba(0,0,0,.86) 0%, rgba(0,0,0,.72) 28%, rgba(0,0,0,0) 78%),
        radial-gradient(600px 900px at 70% 45%, rgba(40,60,80,.55), rgba(0,0,0,0) 70%),
        repeating-radial-gradient(circle at 65% 40%, rgba(255,255,255,.06) 0 2px, transparent 2px 10px);
      filter: blur(.2px) contrast(1.06) saturate(1.02);
      clip-path: polygon(18% 0, 100% 0, 100% 100%, 48% 100%, 20% 86%, 42% 72%, 16% 57%, 38% 42%, 12% 28%, 35% 14%);
    }

    /* Snowy ground fade */
    .ground{
      position:absolute; left:0; right:0; bottom:0;
      height: 44vh;
      background:
        radial-gradient(900px 220px at 50% 100%, rgba(170,240,255,.16), rgba(0,0,0,0) 65%),
        linear-gradient(to top, rgba(220,245,255,.16) 0%, rgba(10,15,30,.08) 25%, rgba(0,0,0,0) 70%);
      transform: translate3d(calc(var(--parallaxX) * .06), calc(var(--parallaxY) * .06), 20px);
      pointer-events:none;
    }

    /* Lake (ice) */
    .lake{
      position:absolute;
      left: 50%;
      top: 62%;
      width: min(980px, 96vw);
      height: min(520px, 56vh);
      transform: translate(-50%, -50%) translate3d(calc(var(--parallaxX) * .09), calc(var(--parallaxY) * .09), 40px);
      clip-path: ellipse(46% 22% at 50% 68%);
      filter: saturate(1.08) contrast(1.05);
      pointer-events:none;
    }

    .lake::before{
      content:"";
      position:absolute; inset:-2%;
      background:
        radial-gradient(closest-side at 50% 72%, rgba(0, 190, 255, .70) 0%, rgba(0, 160, 255, .40) 30%, rgba(0,0,0,0) 68%),
        radial-gradient(closest-side at 50% 80%, rgba(220, 252, 255, .40) 0%, rgba(0,0,0,0) 64%),
        radial-gradient(closest-side at 50% 65%, rgba(12, 28, 60, .88) 0%, rgba(3, 8, 18, .92) 45%, rgba(0,0,0,0) 76%),
        linear-gradient(to bottom, rgba(180,245,255,.12) 0%, rgba(0,0,0,0) 55%);
      mix-blend-mode: screen;
      opacity: .95;
    }

    .lake::after{
      content:"";
      position:absolute; inset:-3%;
      background:
        radial-gradient(closest-side at 50% 70%, rgba(255,255,255,.18) 0%, rgba(255,255,255,.06) 32%, rgba(0,0,0,0) 60%),
        radial-gradient(closest-side at 50% 78%, rgba(255,255,255,.12) 0%, rgba(0,0,0,0) 62%),
        radial-gradient(closest-side at 50% 92%, rgba(0,0,0,.32) 0%, rgba(0,0,0,0) 70%);
      mix-blend-mode: overlay;
      opacity: .65;
      filter: blur(.2px);
    }

    #lakeCanvas{
      position:absolute; inset:0;
      width:100%; height:100%;
      display:block;
      opacity: .90;
      mix-blend-mode: screen;
      filter: blur(.1px);
    }

    /* Center UI */
    .ui{
      position:absolute; inset:0;
      display:grid;
      place-items:center;
      pointer-events:none;
      transform: translate3d(0,0,140px);
    }

    .enterWrap{
      pointer-events: auto;
      display:flex;
      flex-direction: column;
      align-items:center;
      gap: 14px;
      transform:
        translate3d(calc(var(--parallaxX) * .15), calc(var(--parallaxY) * .15), 0)
        rotateX(var(--tiltX)) rotateY(var(--tiltY));
      transition: transform .12s ease;
    }

    .enter{
      user-select:none;
      letter-spacing: .22em;
      text-transform: uppercase;
      font-weight: 900;
      font-size: clamp(40px, 5.6vw, 86px);
      padding: 18px 28px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.14);
      background:
        linear-gradient(180deg, rgba(255,255,255,.18) 0%, rgba(255,255,255,.05) 26%, rgba(0,0,0,.18) 100%),
        radial-gradient(1000px 260px at 50% 20%, rgba(255,255,255,.10), rgba(0,0,0,0) 60%),
        linear-gradient(90deg, rgba(125,230,255,.14), rgba(255,255,255,.06), rgba(182,255,241,.14));
      color: rgba(245,250,255,.92);
      text-shadow:
        0 12px 28px rgba(0,0,0,.45),
        0 1px 0 rgba(255,255,255,.16);
      box-shadow:
        0 26px 80px rgba(0,0,0,.55),
        inset 0 1px 0 rgba(255,255,255,.18),
        inset 0 -18px 28px rgba(0,0,0,.22);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      transform: translateZ(0);
      cursor: pointer;
      outline: none;
      position: relative;
      overflow: hidden;
    }
    .enter::before{
      content:"";
      position:absolute; inset:-40% -30%;
      background:
        repeating-linear-gradient(110deg,
          rgba(255,255,255,.00) 0 10px,
          rgba(255,255,255,.10) 10px 12px,
          rgba(255,255,255,.00) 12px 22px);
      transform: translateX(-30%) rotate(8deg);
      opacity: .35;
      mix-blend-mode: overlay;
      filter: blur(.2px);
    }
    .enter::after{
      content:"";
      position:absolute; inset:-2px;
      border-radius: 18px;
      box-shadow: 0 0 0 0 rgba(125,230,255,0);
      transition: box-shadow .25s ease, opacity .25s ease;
      opacity: 0;
      pointer-events:none;
    }
    .enter:hover::after{
      opacity: 1;
      box-shadow:
        0 0 0 1px rgba(125,230,255,.20),
        0 0 60px rgba(125,230,255,.25),
        0 0 140px rgba(182,255,241,.12);
    }
    .enter:focus-visible{
      box-shadow:
        0 0 0 4px var(--ring),
        0 26px 80px rgba(0,0,0,.55),
        inset 0 1px 0 rgba(255,255,255,.18),
        inset 0 -18px 28px rgba(0,0,0,.22);
    }
    .subhint{
      font-size: 13px;
      color: var(--muted);
      background: rgba(0,0,0,.22);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 999px;
      padding: 8px 12px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 18px 50px rgba(0,0,0,.35);
      display:flex;
      align-items:center;
      gap: 10px;
      max-width: min(560px, 92vw);
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(245,250,255,.86);
    }

    /* Top bar controls */
    .topbar{
      position:absolute;
      top: 18px;
      left: 18px;
      right: 18px;
      display:flex;
      align-items:flex-start;
      justify-content: space-between;
      gap: 12px;
      z-index: 60;
      pointer-events:none;
      transform: translate3d(0,0,160px);
    }
    .brand{
      pointer-events: auto;
      display:flex;
      flex-direction: column;
      gap: 6px;
      padding: 12px 14px;
      border-radius: 16px;
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(0,0,0,.18));
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: 0 24px 60px rgba(0,0,0,.36);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      max-width: min(520px, 62vw);
    }
    .brand .title{
      display:flex;
      align-items:center;
      gap: 10px;
      font-weight: 800;
      letter-spacing: .02em;
      color: rgba(245,250,255,.92);
      line-height: 1.2;
    }
    .dot{
      width: 10px; height: 10px;
      border-radius: 50%;
      background: radial-gradient(circle at 35% 30%, rgba(255,255,255,.9), rgba(125,230,255,.65) 35%, rgba(125,230,255,.10) 70%, transparent 72%);
      box-shadow: 0 0 0 2px rgba(125,230,255,.10), 0 0 26px rgba(125,230,255,.20);
      flex: 0 0 auto;
    }
    .brand .meta{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.35;
    }
    .pill{
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      padding: 6px 10px;
      border-radius: 999px;
      display:flex;
      align-items:center;
      gap: 8px;
    }
    .pill b{
      color: rgba(245,250,255,.92);
      font-weight: 800;
    }

    .controls{
      pointer-events:auto;
      display:flex;
      flex-direction: column;
      gap: 10px;
      align-items: flex-end;
      max-width: min(560px, 96vw);
    }

    .panel{
      width: min(560px, 96vw);
      border-radius: 18px;
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(0,0,0,.22));
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: 0 28px 80px rgba(0,0,0,.40);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      overflow: hidden;
    }
    .panel header{
      display:flex;
      align-items:center;
      justify-content: space-between;
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,.10);
    }
    .panel header .h{
      font-weight: 900;
      letter-spacing: .02em;
      color: rgba(245,250,255,.92);
      font-size: 13px;
      display:flex;
      align-items:center;
      gap: 10px;
    }
    .panel header .toggle{
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(245,250,255,.86);
      border-radius: 999px;
      padding: 7px 10px;
      cursor: pointer;
      font-weight: 800;
      font-size: 12px;
      letter-spacing: .02em;
      display:flex;
      align-items:center;
      gap: 8px;
      user-select:none;
      outline:none;
    }
    .panel header .toggle:focus-visible{
      box-shadow: 0 0 0 4px var(--ring);
    }
    .panel .content{
      padding: 12px 14px 14px;
      display:grid;
      gap: 12px;
    }
    .row{
      display:grid;
      gap: 10px;
      grid-template-columns: 1fr 1fr;
    }
    @media (max-width: 880px){
      .topbar{ flex-direction: column; align-items: stretch; }
      .controls{ align-items: stretch; }
      .row{ grid-template-columns: 1fr; }
      .brand{ max-width: 100%; }
    }

    label{
      display:flex;
      flex-direction: column;
      gap: 6px;
      font-size: 12px;
      color: var(--muted);
    }
    label .lab{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
    }
    .val{
      font-variant-numeric: tabular-nums;
      color: rgba(245,250,255,.84);
      font-weight: 800;
    }

    input[type="range"]{
      width: 100%;
      accent-color: var(--accent);
    }
    select, button, input[type="file"]{
      font: inherit;
    }

    .actions{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items:center;
      justify-content: flex-end;
    }
    .btn{
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(245,250,255,.90);
      border-radius: 14px;
      padding: 10px 12px;
      cursor:pointer;
      font-weight: 850;
      letter-spacing: .01em;
      transition: transform .12s ease, background .15s ease, border-color .15s ease;
      user-select:none;
      display:flex;
      align-items:center;
      gap: 10px;
      outline:none;
    }
    .btn:hover{ transform: translateY(-1px); background: rgba(255,255,255,.09); border-color: rgba(125,230,255,.22); }
    .btn:active{ transform: translateY(0px); }
    .btn:focus-visible{ box-shadow: 0 0 0 4px var(--ring); }

    .btn.primary{
      background: linear-gradient(180deg, rgba(125,230,255,.22), rgba(255,255,255,.06));
      border-color: rgba(125,230,255,.28);
    }
    .btn.danger{
      border-color: rgba(255,90,122,.25);
      background: linear-gradient(180deg, rgba(255,90,122,.18), rgba(255,255,255,.05));
    }

    .fileRow{
      display:flex;
      gap: 10px;
      align-items:center;
      justify-content: space-between;
      border: 1px dashed rgba(255,255,255,.18);
      background: rgba(0,0,0,.18);
      padding: 10px 12px;
      border-radius: 14px;
    }
    .fileRow .hint{
      color: var(--muted);
      font-size: 12px;
      line-height: 1.35;
    }
    .fileRow input[type="file"]{
      max-width: 210px;
      color: rgba(245,250,255,.86);
    }
    .dropZone{
      position:absolute; inset:0;
      border-radius: 18px;
      background: rgba(125,230,255,.08);
      border: 1px dashed rgba(125,230,255,.35);
      display:none;
      place-items:center;
      text-align:center;
      padding: 14px;
      color: rgba(245,250,255,.92);
      pointer-events:none;
    }
    .panel.drag .dropZone{ display:grid; }

    /* "Entered" transition */
    .entered .enterWrap{
      transform: translate3d(calc(var(--parallaxX) * .15), calc(var(--parallaxY) * .15), 0) rotateX(var(--tiltX)) rotateY(var(--tiltY)) scale(.92);
      opacity: .0;
      transition: transform .55s ease, opacity .45s ease;
      pointer-events:none;
    }
    .entered .lake{
      transform: translate(-50%, -50%) translate3d(calc(var(--parallaxX) * .09), calc(var(--parallaxY) * .09), 40px) scale(1.08);
      transition: transform .65s ease;
    }
    .entered .atmo{
      opacity: 1;
      background:
        radial-gradient(900px 520px at 50% 62%, rgba(160, 230, 255, .10) 0%, rgba(6,8,16,0) 62%),
        radial-gradient(1200px 900px at 50% 78%, rgba(0,0,0,.38) 0%, rgba(0,0,0,.62) 60%, rgba(0,0,0,.90) 100%);
      transition: opacity .6s ease, background .6s ease;
    }

    .portalCard{
      position:absolute;
      left: 50%;
      top: 72%;
      transform: translate(-50%, -50%) translate3d(0,0,170px);
      width: min(720px, 92vw);
      border-radius: 22px;
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(0,0,0,.26));
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: 0 42px 120px rgba(0,0,0,.55);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      padding: 14px;
      display:none;
      pointer-events:auto;
    }
    .entered .portalCard{ display:block; }

    .portalCard .grid{
      display:grid;
      gap: 12px;
      grid-template-columns: 1.2fr .8fr;
      align-items: start;
    }
    @media (max-width: 860px){
      .portalCard{ top: 76%; }
      .portalCard .grid{ grid-template-columns: 1fr; }
    }
    .portalCard h2{
      margin: 4px 0 6px;
      font-size: 16px;
      letter-spacing: .02em;
    }
    .portalCard p{
      margin: 0;
      color: var(--muted);
      font-size: 12.5px;
      line-height: 1.6;
    }
    .miniStats{
      display:grid;
      gap: 10px;
      align-content: start;
    }
    .stat{
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      padding: 10px 12px;
      display:flex;
      justify-content: space-between;
      gap: 10px;
      font-size: 12px;
      color: var(--muted);
    }
    .stat .n{
      color: rgba(245,250,255,.92);
      font-weight: 900;
      font-variant-numeric: tabular-nums;
    }
    .portalCard .footer{
      margin-top: 10px;
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .srOnly{
      position:absolute;
      width:1px; height:1px;
      padding:0; margin:-1px;
      overflow:hidden; clip:rect(0,0,0,0);
      white-space:nowrap; border:0;
    }

    /* Respect reduced motion */
    @media (prefers-reduced-motion: reduce){
      .enterWrap, .frame, .lake, .bgImage, .bgProcedural, #snowCanvas, #skyCanvas { transition: none !important; }
      body::before{ display:none; }
    }
  </style>
</head>
<body>
  <div class="app" id="app" aria-label="مشهد شتوي ثلاثي الأبعاد مع زر دخول">
    <div class="scene" id="scene">
      <div class="bgProcedural" id="bgProcedural" aria-hidden="true"></div>
      <div class="bgImage" id="bgImage" aria-hidden="true"></div>

      <canvas class="layer" id="skyCanvas" aria-hidden="true"></canvas>

      <div class="ground" aria-hidden="true"></div>

      <div class="lake" aria-hidden="true">
        <canvas id="lakeCanvas"></canvas>
      </div>

      <div class="frame" aria-hidden="true">
        <div class="left"></div>
        <div class="right"></div>
      </div>

      <canvas class="layer" id="snowCanvas" aria-hidden="true"></canvas>

      <div class="atmo" aria-hidden="true"></div>

      <div class="ui">
        <div class="enterWrap">
          <button class="enter" id="enterBtn" aria-label="Enter">ENTER</button>
          <div class="subhint" aria-label="تلميحات">
            <span>حركة 3D حسب الماوس/الجيروسكوب + ثلج واقعي + جليد متحرك (بدون تهنيج قدر الإمكان)</span>
            <span class="kbd" aria-hidden="true">Space</span>
            <span class="kbd" aria-hidden="true">Enter</span>
          </div>
        </div>
      </div>

      <div class="portalCard" id="portalCard" role="dialog" aria-modal="true" aria-label="لوحة داخل البوابة">
        <div class="grid">
          <div>
            <h2>داخل البوابة</h2>
            <p>
              لو عايز “نفس الصورة بالظبط”: ارفع الصورة كخلفية من الإعدادات (أعلى يمين) وسيتم إضافة عمق 3D + نجوم/ثلج/جليد فوقها.
              ولو ما رفعتهاش، الصفحة تعمل مشهد شتوي مولَّد تلقائيًا.
            </p>
          </div>
          <div class="miniStats" aria-label="مؤشرات الأداء">
            <div class="stat"><span>FPS (تقريبي)</span><span class="n" id="fpsVal">—</span></div>
            <div class="stat"><span>جودة تلقائية</span><span class="n" id="autoVal">—</span></div>
            <div class="stat"><span>عدد الثلج</span><span class="n" id="snowVal">—</span></div>
          </div>
        </div>
        <div class="footer">
          <button class="btn" id="backBtn" aria-label="رجوع">رجوع</button>
          <button class="btn primary" id="toggleSoundBtn" aria-label="تشغيل أو إيقاف الصوت">الصوت: إيقاف</button>
        </div>
      </div>
    </div>

    <div class="topbar" aria-hidden="false">
      <div class="brand" aria-label="معلومات">
        <div class="title"><span class="dot" aria-hidden="true"></span>بوابة الشتاء (3D)</div>
        <div class="meta">
          <span class="pill"><b>Parallax</b> حسب الحركة</span>
          <span class="pill"><b>Auto</b> يقلل الحمل تلقائيًا</span>
          <span class="pill"><b>رفع صورة</b> لتطابق الشكل</span>
        </div>
      </div>

      <div class="controls" aria-label="إعدادات">
        <div class="panel" id="panel">
          <header>
            <div class="h">الإعدادات</div>
            <button class="toggle" id="collapseBtn" aria-expanded="true" aria-controls="panelContent">إخفاء</button>
          </header>
          <div class="content" id="panelContent">
            <div class="fileRow" aria-label="رفع خلفية">
              <div class="hint">
                لو عايز نفس الصورة 100%: اسحب الصورة هنا أو اختارها.<br>
                (بيتم استخدامها محليًا داخل الصفحة فقط)
              </div>
              <input type="file" id="bgFile" accept="image/*" aria-label="اختيار صورة خلفية" />
            </div>

            <div class="row">
              <label>
                <div class="lab"><span>الجودة</span><span class="val" id="qualityVal">Auto</span></div>
                <select id="qualitySelect" aria-label="اختيار الجودة">
                  <option value="auto" selected>Auto (مُوصى به)</option>
                  <option value="high">High</option>
                  <option value="medium">Medium</option>
                  <option value="low">Low</option>
                </select>
              </label>

              <label>
                <div class="lab"><span>قوة الـ 3D</span><span class="val" id="parallaxVal">65%</span></div>
                <input id="parallaxRange" type="range" min="0" max="100" value="65" />
              </label>
            </div>

            <div class="row">
              <label>
                <div class="lab"><span>كثافة الثلج</span><span class="val" id="snowDensityVal">70%</span></div>
                <input id="snowRange" type="range" min="0" max="100" value="70" />
              </label>

              <label>
                <div class="lab"><span>كثافة النجوم</span><span class="val" id="starDensityVal">60%</span></div>
                <input id="starsRange" type="range" min="0" max="100" value="60" />
              </label>
            </div>

            <div class="row">
              <label>
                <div class="lab"><span>وميض النجوم</span><span class="val" id="twinkleVal">35%</span></div>
                <input id="twinkleRange" type="range" min="0" max="100" value="35" />
              </label>

              <label>
                <div class="lab"><span>لمعة الجليد</span><span class="val" id="iceVal">55%</span></div>
                <input id="iceRange" type="range" min="0" max="100" value="55" />
              </label>
            </div>

            <div class="actions">
              <button class="btn" id="resetBtn" aria-label="إرجاع الإعدادات">إرجاع</button>
              <button class="btn danger" id="clearBgBtn" aria-label="إزالة الخلفية">إزالة الصورة</button>
              <button class="btn primary" id="enterBtn2" aria-label="Enter">ENTER</button>
            </div>
            <div class="dropZone" id="dropZone" aria-hidden="true">
              اسحب الصورة وأفلتها هنا لتصبح الخلفية
            </div>
          </div>
        </div>
      </div>
    </div>

    <p class="srOnly" id="a11yNote">
      استخدم زر Enter للدخول. يمكنك رفع صورة لتصبح الخلفية. يوجد إعدادات لتقليل الحمل إذا شعرت بتقطيع.
    </p>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      "use strict";
      const app = document.getElementById('app');
      const scene = document.getElementById('scene');

      const skyCanvas = document.getElementById('skyCanvas');
      const snowCanvas = document.getElementById('snowCanvas');
      const lakeCanvas = document.getElementById('lakeCanvas');

      const enterBtn = document.getElementById('enterBtn');
      const enterBtn2 = document.getElementById('enterBtn2');
      const backBtn = document.getElementById('backBtn');
      const portalCard = document.getElementById('portalCard');

      const fpsVal = document.getElementById('fpsVal');
      const autoVal = document.getElementById('autoVal');
      const snowVal = document.getElementById('snowVal');

      const panel = document.getElementById('panel');
      const panelContent = document.getElementById('panelContent');
      const collapseBtn = document.getElementById('collapseBtn');
      const dropZone = document.getElementById('dropZone');

      const bgFile = document.getElementById('bgFile');
      const bgImage = document.getElementById('bgImage');

      const qualitySelect = document.getElementById('qualitySelect');
      const qualityVal = document.getElementById('qualityVal');

      const parallaxRange = document.getElementById('parallaxRange');
      const parallaxVal = document.getElementById('parallaxVal');

      const snowRange = document.getElementById('snowRange');
      const snowDensityVal = document.getElementById('snowDensityVal');

      const starsRange = document.getElementById('starsRange');
      const starDensityVal = document.getElementById('starDensityVal');

      const twinkleRange = document.getElementById('twinkleRange');
      const twinkleVal = document.getElementById('twinkleVal');

      const iceRange = document.getElementById('iceRange');
      const iceVal = document.getElementById('iceVal');

      const resetBtn = document.getElementById('resetBtn');
      const clearBgBtn = document.getElementById('clearBgBtn');

      const toggleSoundBtn = document.getElementById('toggleSoundBtn');

      const prefersReducedMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      // -----------------------------
      // Helpers
      // -----------------------------
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const lerp = (a, b, t) => a + (b - a) * t;
      const rand = (min, max) => min + Math.random() * (max - min);
      const now = () => performance.now();

      function setCSSVar(name, val){ document.documentElement.style.setProperty(name, val); }

      // -----------------------------
      // Quality system (auto-adaptive)
      // -----------------------------
      const state = {
        qualityMode: 'auto', // auto | high | medium | low
        autoTier: 'High',
        dprCap: 2,
        parallaxStrength: 0.65,
        snowDensity: 0.70,
        starDensity: 0.60,
        twinkle: 0.35,
        iceShine: 0.55,
        hasBgImage: false,
        audioOn: false,
      };

      const tiers = {
        high:   { dprCap: 2.0, snowBase: 900, starsBase: 1400, twinkleFPSCost: 1.0 },
        medium: { dprCap: 1.6, snowBase: 650, starsBase: 1050, twinkleFPSCost: 0.8 },
        low:    { dprCap: 1.25, snowBase: 380, starsBase: 650, twinkleFPSCost: 0.6 }
      };

      function currentTier(){
        if(state.qualityMode === 'auto'){
          if(state.autoTier === 'High') return tiers.high;
          if(state.autoTier === 'Medium') return tiers.medium;
          return tiers.low;
        }
        return tiers[state.qualityMode] || tiers.medium;
      }

      // -----------------------------
      // Resize handling
      // -----------------------------
      let vw = 0, vh = 0, dpr = 1;

      function resizeAll(){
        vw = Math.max(320, window.innerWidth);
        vh = Math.max(480, window.innerHeight);

        const tier = currentTier();
        dpr = Math.min(window.devicePixelRatio || 1, tier.dprCap);

        // Sky
        skyCanvas.width = Math.floor(vw * dpr);
        skyCanvas.height = Math.floor(vh * dpr);

        // Snow
        snowCanvas.width = Math.floor(vw * dpr);
        snowCanvas.height = Math.floor(vh * dpr);

        // Lake canvas matches its DOM box
        const lakeRect = lakeCanvas.parentElement.getBoundingClientRect();
        lakeCanvas.width = Math.max(1, Math.floor(lakeRect.width * dpr));
        lakeCanvas.height = Math.max(1, Math.floor(lakeRect.height * dpr));

        buildSky(true);
        buildSnow(true);
        buildLake(true);
      }

      // -----------------------------
      // Sky (stars + milky way)
      // -----------------------------
      const sky = {
        stars: [],
        clouds: [],
        needsRebuild: true,
      };

      function buildSky(force=false){
        try{
          const tier = currentTier();
          const ctx = skyCanvas.getContext('2d', { alpha: true, desynchronized: true });
          if(!ctx) return;

          const W = skyCanvas.width, H = skyCanvas.height;
          const starCount = Math.floor(tier.starsBase * clamp(state.starDensity, 0, 1) * (W*H) / (1200*800*dpr*dpr));

          if(force || sky.stars.length === 0){
            sky.stars = [];
            for(let i=0;i<starCount;i++){
              // Bias to top half
              const y = Math.pow(Math.random(), 1.5) * H;
              const x = Math.random() * W;
              const r = Math.pow(Math.random(), 2.6) * 1.6 + 0.2;
              const base = Math.pow(Math.random(), 1.2);
              const tw = Math.random() * 2.2 + 0.6;
              const hueBias = Math.random();
              const tint = hueBias < 0.78 ? [210, 235, 255] : (hueBias < 0.92 ? [235, 245, 255] : [255, 240, 220]);
              sky.stars.push({ x, y, r, base, tw, ph: Math.random()*Math.PI*2, tint });
            }

            // Milky-way-ish clouds (blurred blobs along a diagonal band)
            sky.clouds = [];
            const bandAngle = -18 * Math.PI / 180;
            const bandCX = W * 0.52, bandCY = H * 0.26;
            const steps = 120;
            for(let i=0;i<steps;i++){
              const t = i/(steps-1);
              const along = lerp(-W*0.25, W*0.55, t);
              const cx = bandCX + along*Math.cos(bandAngle) + rand(-W*0.02, W*0.02);
              const cy = bandCY + along*Math.sin(bandAngle) + rand(-H*0.02, H*0.02);
              const rr = rand(70, 220) * dpr;
              const a = rand(0.015, 0.05);
              sky.clouds.push({ cx, cy, rr, a });
            }
          }

          // Draw static base sky once
          ctx.setTransform(1,0,0,1,0,0);
          ctx.clearRect(0,0,W,H);

          // deep gradient
          const g = ctx.createLinearGradient(0,0,0,H);
          g.addColorStop(0, '#050a22');
          g.addColorStop(0.45, '#02030a');
          g.addColorStop(1, '#010107');
          ctx.fillStyle = g;
          ctx.fillRect(0,0,W,H);

          // Milky way haze
          ctx.save();
          ctx.globalCompositeOperation = 'screen';
          for(const c of sky.clouds){
            const gg = ctx.createRadialGradient(c.cx, c.cy, 0, c.cx, c.cy, c.rr);
            gg.addColorStop(0, `rgba(170, 220, 255, ${c.a})`);
            gg.addColorStop(0.45, `rgba(120, 190, 255, ${c.a*0.55})`);
            gg.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = gg;
            ctx.beginPath();
            ctx.arc(c.cx, c.cy, c.rr, 0, Math.PI*2);
            ctx.fill();
          }
          ctx.restore();

          // stars (base)
          ctx.save();
          ctx.globalCompositeOperation = 'screen';
          for(const s of sky.stars){
            const a = 0.14 + 0.86 * s.base;
            ctx.fillStyle = `rgba(${s.tint[0]},${s.tint[1]},${s.tint[2]},${a})`;
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
            ctx.fill();
          }
          ctx.restore();

          // subtle vignette
          ctx.save();
          const vg = ctx.createRadialGradient(W*0.5, H*0.48, Math.min(W,H)*0.2, W*0.5, H*0.48, Math.min(W,H)*0.75);
          vg.addColorStop(0, 'rgba(0,0,0,0)');
          vg.addColorStop(1, 'rgba(0,0,0,0.55)');
          ctx.fillStyle = vg;
          ctx.fillRect(0,0,W,H);
          ctx.restore();

          sky.needsRebuild = false;
        } catch(e){
          console.error('buildSky error', e);
        }
      }

      // Twinkle overlay (lightweight)
      function drawTwinkle(t){
        try{
          const ctx = skyCanvas.getContext('2d', { alpha: true, desynchronized: true });
          if(!ctx) return;
          const W = skyCanvas.width, H = skyCanvas.height;

          // small clear with low alpha to avoid heavy redraw: draw additive sparkles only
          const tw = clamp(state.twinkle, 0, 1);
          if(tw < 0.02) return;

          ctx.save();
          ctx.globalCompositeOperation = 'screen';
          const n = Math.floor(120 * tw);
          for(let i=0;i<n;i++){
            const s = sky.stars[(Math.random() * sky.stars.length) | 0];
            if(!s) continue;
            const k = (Math.sin(t*0.001*s.tw + s.ph) * 0.5 + 0.5);
            const a = (0.02 + 0.08 * tw) * k;
            const rr = s.r * (1.4 + 2.0*k);
            const gg = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, rr*3.4);
            gg.addColorStop(0, `rgba(${s.tint[0]},${s.tint[1]},${s.tint[2]},${a})`);
            gg.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = gg;
            ctx.beginPath();
            ctx.arc(s.x, s.y, rr*3.4, 0, Math.PI*2);
            ctx.fill();
          }
          ctx.restore();

          // Very light fade to prevent accumulation
          ctx.save();
          ctx.globalCompositeOperation = 'source-over';
          ctx.fillStyle = `rgba(0,0,0,${0.012 + 0.02*tw})`;
          ctx.fillRect(0,0,W,H);
          ctx.restore();
        } catch(e){
          console.error('drawTwinkle error', e);
        }
      }

      // -----------------------------
      // Snow (depth particles)
      // -----------------------------
      const snow = {
        flakes: [],
        targetCount: 500,
        wind: 0,
        qualityFactor: 1,
        needsRebuild: true
      };

      function computeSnowTarget(){
        const tier = currentTier();
        const W = snowCanvas.width, H = snowCanvas.height;
        const base = tier.snowBase;
        const density = clamp(state.snowDensity, 0, 1);
        const areaScale = (W*H) / (1200*800*dpr*dpr);
        let n = Math.floor(base * density * areaScale);
        // Keep sane bounds
        n = clamp(n, 0, 1400);
        return n;
      }

      function buildSnow(force=false){
        try{
          const ctx = snowCanvas.getContext('2d', { alpha: true, desynchronized: true });
          if(!ctx) return;

          snow.targetCount = computeSnowTarget();
          if(force || snow.flakes.length === 0){
            snow.flakes = [];
            for(let i=0;i<snow.targetCount;i++) snow.flakes.push(makeFlake(true));
          } else {
            // Adjust count smoothly
            while(snow.flakes.length < snow.targetCount) snow.flakes.push(makeFlake(true));
            while(snow.flakes.length > snow.targetCount) snow.flakes.pop();
          }
          snow.needsRebuild = false;
        } catch(e){
          console.error('buildSnow error', e);
        }
      }

      function makeFlake(spawnAnywhere=false){
        const W = snowCanvas.width, H = snowCanvas.height;
        const z = Math.pow(Math.random(), 1.9); // 0 near, 1 far
        const x = Math.random() * W;
        const y = spawnAnywhere ? Math.random() * H : -rand(0, H*0.15);
        const r = (1.4 + (1-z) * 3.6) * dpr;
        const v = (0.45 + (1-z) * 2.2) * dpr;
        const sway = (0.2 + Math.random()*0.9) * dpr;
        const phase = Math.random() * Math.PI*2;
        const drift = rand(-0.6, 0.6) * dpr;
        const sparkle = Math.random();
        return { x, y, z, r, v, sway, phase, drift, sparkle };
      }

      function stepSnow(t, dt){
        try{
          const ctx = snowCanvas.getContext('2d', { alpha: true, desynchronized: true });
          if(!ctx) return;
          const W = snowCanvas.width, H = snowCanvas.height;

          ctx.setTransform(1,0,0,1,0,0);
          // Motion blur-ish clear
          ctx.globalCompositeOperation = 'source-over';
          ctx.fillStyle = 'rgba(0,0,0,0.10)';
          ctx.fillRect(0,0,W,H);

          // Wind (slow)
          const wind = Math.sin(t * 0.00022) * 0.65 + Math.sin(t * 0.000073) * 0.35;
          snow.wind = wind;

          ctx.globalCompositeOperation = 'screen';
          for(let i=0;i<snow.flakes.length;i++){
            const f = snow.flakes[i];
            const depth = 1 - f.z;
            const wob = Math.sin(t*0.0012 + f.phase) * f.sway;
            const vx = (wind * (0.85 + depth*1.6) + f.drift) * (0.55 + depth*0.85);

            f.x += vx * dt * 0.06;
            f.y += f.v * dt * 0.08;

            if(f.y > H + 10*dpr || f.x < -30*dpr || f.x > W + 30*dpr){
              snow.flakes[i] = makeFlake(false);
              continue;
            }

            const alpha = clamp(0.07 + depth*0.38, 0.06, 0.55);
            const sparkle = (f.sparkle > 0.965) ? (0.15 + 0.2*Math.sin(t*0.01 + f.phase)) : 0;
            const a = clamp(alpha + sparkle, 0, 0.65);

            // Draw as soft radial blob
            const x = f.x + wob;
            const y = f.y;

            const rr = f.r;
            const g = ctx.createRadialGradient(x, y, 0, x, y, rr*3.2);
            g.addColorStop(0, `rgba(255,255,255,${a})`);
            g.addColorStop(0.35, `rgba(210,245,255,${a*0.35})`);
            g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.arc(x, y, rr*3.2, 0, Math.PI*2);
            ctx.fill();
          }
        } catch(e){
          console.error('stepSnow error', e);
        }
      }

      // -----------------------------
      // Lake shimmer + cracks
      // -----------------------------
      const lake = {
        cracks: null,
        noiseSeeds: [],
        needsRebuild: true
      };

      function buildLake(force=false){
        try{
          const ctx = lakeCanvas.getContext('2d', { alpha: true, desynchronized: true });
          if(!ctx) return;
          const W = lakeCanvas.width, H = lakeCanvas.height;

          if(force || !lake.cracks){
            // Pre-render crack lines onto an offscreen canvas
            const off = document.createElement('canvas');
            off.width = W;
            off.height = H;
            const octx = off.getContext('2d');
            octx.clearRect(0,0,W,H);

            // Generate a few branching polylines
            const lines = 22;
            for(let i=0;i<lines;i++){
              const startX = rand(W*0.18, W*0.82);
              const startY = rand(H*0.58, H*0.95);
              const segs = 10 + (Math.random()*14|0);
              let x = startX, y = startY;
              let ang = rand(-Math.PI*0.95, -Math.PI*0.05);
              let w = rand(0.35, 0.9) * dpr;

              octx.beginPath();
              octx.moveTo(x,y);
              for(let s=0;s<segs;s++){
                const step = rand(14, 46) * dpr;
                ang += rand(-0.45, 0.45);
                x += Math.cos(ang) * step;
                y += Math.sin(ang) * step;
                // constrain
                x = clamp(x, -W*0.1, W*1.1);
                y = clamp(y, -H*0.2, H*1.2);
                octx.lineTo(x,y);

                // occasional branch
                if(Math.random() < 0.18){
                  octx.save();
                  octx.strokeStyle = `rgba(210,255,255,${rand(0.08,0.18)})`;
                  octx.lineWidth = w * rand(0.6, 0.9);
                  octx.shadowColor = 'rgba(120,230,255,0.25)';
                  octx.shadowBlur = 10*dpr;
                  octx.stroke();
                  octx.restore();

                  octx.beginPath();
                  octx.moveTo(x,y);
                }
              }

              octx.strokeStyle = `rgba(220,255,255,${rand(0.08,0.22)})`;
              octx.lineWidth = w;
              octx.lineCap = 'round';
              octx.lineJoin = 'round';
              octx.shadowColor = 'rgba(90,210,255,0.22)';
              octx.shadowBlur = 14*dpr;
              octx.stroke();
            }

            // Frosty micro-scratches
            for(let i=0;i<260;i++){
              const x1 = rand(W*0.15, W*0.85);
              const y1 = rand(H*0.55, H*0.98);
              const len = rand(10, 55)*dpr;
              const ang = rand(-Math.PI, 0);
              const x2 = x1 + Math.cos(ang)*len;
              const y2 = y1 + Math.sin(ang)*len;
              octx.strokeStyle = `rgba(200,245,255,${rand(0.02,0.05)})`;
              octx.lineWidth = rand(0.25, 0.7)*dpr;
              octx.beginPath();
              octx.moveTo(x1,y1);
              octx.lineTo(x2,y2);
              octx.stroke();
            }

            lake.cracks = off;
            lake.noiseSeeds = Array.from({length: 14}, () => ({
              x: rand(0, W), y: rand(0, H),
              r: rand(90, 210)*dpr,
              a: rand(0.03, 0.09)
            }));
          }

          lake.needsRebuild = false;
        } catch(e){
          console.error('buildLake error', e);
        }
      }

      function drawLake(t){
        try{
          const ctx = lakeCanvas.getContext('2d', { alpha: true, desynchronized: true });
          if(!ctx) return;
          const W = lakeCanvas.width, H = lakeCanvas.height;
          const shine = clamp(state.iceShine, 0, 1);

          ctx.setTransform(1,0,0,1,0,0);
          ctx.clearRect(0,0,W,H);

          // Base ice glow
          const g = ctx.createRadialGradient(W*0.5, H*0.70, 0, W*0.5, H*0.70, Math.max(W,H)*0.62);
          g.addColorStop(0, `rgba(20,190,255,${0.26*shine})`);
          g.addColorStop(0.22, `rgba(15,140,255,${0.18*shine})`);
          g.addColorStop(0.55, 'rgba(0,0,0,0)');
          ctx.fillStyle = g;
          ctx.fillRect(0,0,W,H);

          // Animated shimmer "caustics" via layered waves
          ctx.save();
          ctx.globalCompositeOperation = 'screen';
          const time = t * 0.001;
          const bands = 24;
          for(let i=0;i<bands;i++){
            const yy = H*(0.58 + i*(0.44/(bands-1)));
            const amp = (6 + 10*shine) * dpr;
            const freq = 0.012 + i*0.0007;
            const speed = 0.75 + i*0.05;
            const phase = time*speed + i*1.7;

            ctx.beginPath();
            const x0 = 0;
            const y0 = yy + Math.sin(phase)*amp*0.15;
            ctx.moveTo(x0, y0);

            for(let x=0; x<=W; x+= 12*dpr){
              const y = yy
                + Math.sin(x*freq + phase) * amp
                + Math.sin(x*(freq*1.8) + phase*1.35) * amp*0.35;
              ctx.lineTo(x, y);
            }

            const a = (0.012 + shine*0.03) * (1 - i/bands);
            ctx.strokeStyle = `rgba(210,250,255,${a})`;
            ctx.lineWidth = (1.0 + 1.2*shine) * dpr;
            ctx.shadowColor = `rgba(125,230,255,${0.12 + shine*0.18})`;
            ctx.shadowBlur = 10*dpr;
            ctx.stroke();
          }
          ctx.restore();

          // Soft icy fog patches
          ctx.save();
          ctx.globalCompositeOperation = 'screen';
          for(let i=0;i<lake.noiseSeeds.length;i++){
            const s = lake.noiseSeeds[i];
            const ox = Math.sin(time*0.55 + i*1.9) * 14*dpr;
            const oy = Math.cos(time*0.43 + i*1.3) * 10*dpr;
            const gg = ctx.createRadialGradient(s.x+ox, s.y+oy, 0, s.x+ox, s.y+oy, s.r);
            gg.addColorStop(0, `rgba(210,255,255,${s.a*shine})`);
            gg.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = gg;
            ctx.beginPath();
            ctx.arc(s.x+ox, s.y+oy, s.r, 0, Math.PI*2);
            ctx.fill();
          }
          ctx.restore();

          // Cracks overlay
          if(lake.cracks){
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            // gentle pulsation
            const pulse = 0.85 + 0.15*Math.sin(t*0.0012);
            ctx.globalAlpha = (0.75 + 0.25*shine) * pulse;
            ctx.drawImage(lake.cracks, 0, 0);
            ctx.restore();
          }

          // Edge darkening for depth
          ctx.save();
          ctx.globalCompositeOperation = 'multiply';
          const vg = ctx.createRadialGradient(W*0.5, H*0.70, Math.min(W,H)*0.12, W*0.5, H*0.70, Math.min(W,H)*0.58);
          vg.addColorStop(0, 'rgba(0,0,0,0)');
          vg.addColorStop(1, 'rgba(0,0,0,0.55)');
          ctx.fillStyle = vg;
          ctx.fillRect(0,0,W,H);
          ctx.restore();
        } catch(e){
          console.error('drawLake error', e);
        }
      }

      // -----------------------------
      // Parallax / tilt
      // -----------------------------
      let targetPX = 0, targetPY = 0, currentPX = 0, currentPY = 0;
      let targetTX = 0, targetTY = 0, currentTX = 0, currentTY = 0;

      function applyParallax(){
        const strength = prefersReducedMotion ? 0 : state.parallaxStrength;
        currentPX = lerp(currentPX, targetPX, 0.08);
        currentPY = lerp(currentPY, targetPY, 0.08);
        currentTX = lerp(currentTX, targetTX, 0.08);
        currentTY = lerp(currentTY, targetTY, 0.08);

        const px = currentPX * 18 * strength;
        const py = currentPY * 18 * strength;

        setCSSVar('--parallaxX', `${px.toFixed(2)}px`);
        setCSSVar('--parallaxY', `${py.toFixed(2)}px`);

        const tiltX = (-currentPY * 3.2 * strength);
        const tiltY = (currentPX * 4.0 * strength);
        setCSSVar('--tiltX', `${tiltX.toFixed(3)}deg`);
        setCSSVar('--tiltY', `${tiltY.toFixed(3)}deg`);
      }

      function onPointerMove(e){
        const rect = document.body.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;
        targetPX = (x - 0.5) * 2;
        targetPY = (y - 0.5) * 2;
        targetTX = targetPY;
        targetTY = targetPX;
      }

      // Device orientation (optional)
      let orientEnabled = false;
      function handleOrientation(ev){
        if(prefersReducedMotion) return;
        // gamma: left/right, beta: front/back
        const g = ev.gamma;
        const b = ev.beta;
        if(typeof g !== 'number' || typeof b !== 'number') return;
        const px = clamp(g / 18, -1, 1);
        const py = clamp((b - 10) / 18, -1, 1);
        targetPX = lerp(targetPX, px, 0.35);
        targetPY = lerp(targetPY, py, 0.35);
        targetTX = targetPY;
        targetTY = targetPX;
        orientEnabled = true;
      }

      async function tryEnableOrientation(){
        try{
          if(!('DeviceOrientationEvent' in window)) return;
          // iOS requires permission
          if(typeof DeviceOrientationEvent.requestPermission === 'function'){
            const res = await DeviceOrientationEvent.requestPermission();
            if(res !== 'granted') return;
          }
          window.addEventListener('deviceorientation', handleOrientation, { passive:true });
        } catch(e){
          // ignore
        }
      }

      // -----------------------------
      // UI interactions
      // -----------------------------
      function setEntered(on){
        if(on) app.classList.add('entered');
        else app.classList.remove('entered');
      }

      function enterPortal(){
        setEntered(true);
      }
      function leavePortal(){
        setEntered(false);
      }

      enterBtn.addEventListener('click', enterPortal);
      enterBtn2.addEventListener('click', enterPortal);
      backBtn.addEventListener('click', leavePortal);

      window.addEventListener('keydown', (e) => {
        if(e.code === 'Space' || e.code === 'Enter'){
          // Avoid typing in select
          const tag = (document.activeElement && document.activeElement.tagName) ? document.activeElement.tagName.toLowerCase() : '';
          if(tag === 'input' || tag === 'select' || tag === 'textarea' || tag === 'button') return;
          e.preventDefault();
          if(app.classList.contains('entered')) leavePortal();
          else enterPortal();
        } else if(e.code === 'Escape'){
          if(app.classList.contains('entered')) leavePortal();
        }
      });

      collapseBtn.addEventListener('click', () => {
        const expanded = collapseBtn.getAttribute('aria-expanded') === 'true';
        collapseBtn.setAttribute('aria-expanded', String(!expanded));
        panelContent.style.display = expanded ? 'none' : 'block';
        collapseBtn.textContent = expanded ? 'إظهار' : 'إخفاء';
      });

      // Ranges
      function refreshUI(){
        qualityVal.textContent = state.qualityMode === 'auto' ? 'Auto' : (state.qualityMode[0].toUpperCase() + state.qualityMode.slice(1));
        parallaxVal.textContent = `${Math.round(state.parallaxStrength * 100)}%`;
        snowDensityVal.textContent = `${Math.round(state.snowDensity * 100)}%`;
        starDensityVal.textContent = `${Math.round(state.starDensity * 100)}%`;
        twinkleVal.textContent = `${Math.round(state.twinkle * 100)}%`;
        iceVal.textContent = `${Math.round(state.iceShine * 100)}%`;

        autoVal.textContent = state.qualityMode === 'auto' ? state.autoTier : '—';
        snowVal.textContent = String(snow.targetCount);
      }

      parallaxRange.addEventListener('input', () => {
        state.parallaxStrength = clamp(parseInt(parallaxRange.value,10)/100, 0, 1);
        refreshUI();
      });
      snowRange.addEventListener('input', () => {
        state.snowDensity = clamp(parseInt(snowRange.value,10)/100, 0, 1);
        buildSnow(false);
        refreshUI();
      });
      starsRange.addEventListener('input', () => {
        state.starDensity = clamp(parseInt(starsRange.value,10)/100, 0, 1);
        buildSky(true);
        refreshUI();
      });
      twinkleRange.addEventListener('input', () => {
        state.twinkle = clamp(parseInt(twinkleRange.value,10)/100, 0, 1);
        refreshUI();
      });
      iceRange.addEventListener('input', () => {
        state.iceShine = clamp(parseInt(iceRange.value,10)/100, 0, 1);
        refreshUI();
      });

      qualitySelect.addEventListener('change', () => {
        state.qualityMode = qualitySelect.value;
        resizeAll();
        refreshUI();
      });

      resetBtn.addEventListener('click', () => {
        state.qualityMode = 'auto';
        state.parallaxStrength = 0.65;
        state.snowDensity = 0.70;
        state.starDensity = 0.60;
        state.twinkle = 0.35;
        state.iceShine = 0.55;

        qualitySelect.value = 'auto';
        parallaxRange.value = 65;
        snowRange.value = 70;
        starsRange.value = 60;
        twinkleRange.value = 35;
        iceRange.value = 55;

        resizeAll();
        refreshUI();
      });

      clearBgBtn.addEventListener('click', () => {
        bgImage.style.backgroundImage = '';
        bgImage.classList.remove('on');
        state.hasBgImage = false;
      });

      // Background image upload (exact look)
      function setBackgroundFromFile(file){
        try{
          if(!file || !file.type || !file.type.startsWith('image/')) return;
          const reader = new FileReader();
          reader.onload = () => {
            bgImage.style.backgroundImage = `url(${reader.result})`;
            bgImage.classList.add('on');
            state.hasBgImage = true;
          };
          reader.readAsDataURL(file);
        } catch(e){
          console.error('setBackgroundFromFile error', e);
        }
      }

      bgFile.addEventListener('change', (e) => {
        const file = e.target.files && e.target.files[0];
        setBackgroundFromFile(file);
      });

      // Drag & drop image onto panel
      ;(() => {
        let dragCounter = 0;
        function isImageDrag(ev){
          const dt = ev.dataTransfer;
          if(!dt) return false;
          if(dt.types && Array.from(dt.types).includes('Files')) return true;
          return false;
        }
        window.addEventListener('dragenter', (ev) => {
          if(!isImageDrag(ev)) return;
          dragCounter++;
          panel.classList.add('drag');
          dropZone.setAttribute('aria-hidden', 'false');
          ev.preventDefault();
        });
        window.addEventListener('dragleave', (ev) => {
          if(!isImageDrag(ev)) return;
          dragCounter = Math.max(0, dragCounter - 1);
          if(dragCounter === 0){
            panel.classList.remove('drag');
            dropZone.setAttribute('aria-hidden', 'true');
          }
        });
        window.addEventListener('dragover', (ev) => {
          if(!isImageDrag(ev)) return;
          ev.preventDefault();
        });
        window.addEventListener('drop', (ev) => {
          if(!isImageDrag(ev)) return;
          ev.preventDefault();
          dragCounter = 0;
          panel.classList.remove('drag');
          dropZone.setAttribute('aria-hidden', 'true');
          const file = ev.dataTransfer.files && ev.dataTransfer.files[0];
          setBackgroundFromFile(file);
        });
      })();

      // -----------------------------
      // Audio (wind ambience) - optional
      // -----------------------------
      let audioCtx = null;
      let noiseNode = null;
      let windGain = null;
      let filter1 = null;
      let filter2 = null;
      let lfo = null, lfoGain = null;

      function createNoiseBuffer(ctx){
        const seconds = 2.2;
        const rate = ctx.sampleRate;
        const len = Math.floor(seconds * rate);
        const buf = ctx.createBuffer(1, len, rate);
        const data = buf.getChannelData(0);
        for(let i=0;i<len;i++){
          // pink-ish noise approximation by filtering white in time (simple)
          const w = (Math.random()*2-1);
          data[i] = w;
        }
        return buf;
      }

      function startAudio(){
        try{
          if(state.audioOn) return;
          if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

          // Noise source (looped)
          const src = audioCtx.createBufferSource();
          src.buffer = createNoiseBuffer(audioCtx);
          src.loop = true;

          // Filters to make it "wind"
          filter1 = audioCtx.createBiquadFilter();
          filter1.type = 'lowpass';
          filter1.frequency.value = 650;
          filter1.Q.value = 0.9;

          filter2 = audioCtx.createBiquadFilter();
          filter2.type = 'highpass';
          filter2.frequency.value = 40;
          filter2.Q.value = 0.7;

          windGain = audioCtx.createGain();
          windGain.gain.value = 0.0;

          // LFO for gusts
          lfo = audioCtx.createOscillator();
          lfo.type = 'sine';
          lfo.frequency.value = 0.08;

          lfoGain = audioCtx.createGain();
          lfoGain.gain.value = 0.24;

          lfo.connect(lfoGain);
          lfoGain.connect(windGain.gain);

          src.connect(filter1);
          filter1.connect(filter2);
          filter2.connect(windGain);
          windGain.connect(audioCtx.destination);

          src.start();
          lfo.start();

          // Fade in
          const t0 = audioCtx.currentTime;
          windGain.gain.setValueAtTime(0.0, t0);
          windGain.gain.linearRampToValueAtTime(0.22, t0 + 1.2);

          noiseNode = src;
          state.audioOn = true;
          toggleSoundBtn.textContent = 'الصوت: تشغيل';
        } catch(e){
          console.error('startAudio error', e);
        }
      }

      function stopAudio(){
        try{
          if(!state.audioOn) return;
          if(!audioCtx) return;

          const t0 = audioCtx.currentTime;
          if(windGain){
            windGain.gain.cancelScheduledValues(t0);
            windGain.gain.setValueAtTime(windGain.gain.value, t0);
            windGain.gain.linearRampToValueAtTime(0.0, t0 + 0.35);
          }
          setTimeout(() => {
            try{
              if(noiseNode) noiseNode.stop();
              if(lfo) lfo.stop();
              noiseNode = null;
              lfo = null;
              lfoGain = null;
              windGain = null;
              filter1 = null;
              filter2 = null;
            } catch(_) {}
          }, 450);

          state.audioOn = false;
          toggleSoundBtn.textContent = 'الصوت: إيقاف';
        } catch(e){
          console.error('stopAudio error', e);
        }
      }

      toggleSoundBtn.addEventListener('click', async () => {
        try{
          if(!state.audioOn){
            // user gesture - safe to start context
            await tryEnableOrientation(); // bonus: ask for motion permission once user clicks
            startAudio();
          } else {
            stopAudio();
          }
        } catch(e){
          console.error('toggleSound error', e);
        }
      });

      // -----------------------------
      // Performance / Auto quality
      // -----------------------------
      const perf = {
        lastT: now(),
        fpsEMA: 60,
        frame: 0,
        lastAdjustT: now(),
      };

      function autoAdjustQuality(t){
        // adjust every ~1.2s
        if(state.qualityMode !== 'auto') return;
        if(t - perf.lastAdjustT < 1200) return;
        perf.lastAdjustT = t;

        const fps = perf.fpsEMA;

        // Decide tier
        let next = state.autoTier;
        if(fps > 54) next = 'High';
        else if(fps > 40) next = 'Medium';
        else next = 'Low';

        if(next !== state.autoTier){
          state.autoTier = next;
          // re-resize to apply DPR cap + rebuild
          resizeAll();
        } else {
          // Still adjust snow count gradually (no resize)
          buildSnow(false);
        }
      }

      // -----------------------------
      // Main loop
      // -----------------------------
      function tick(t){
        const dt = Math.min(40, t - perf.lastT);
        perf.lastT = t;

        // fps EMA
        const fps = 1000 / Math.max(1, dt);
        perf.fpsEMA = perf.fpsEMA * 0.92 + fps * 0.08;

        // Update CSS parallax
        applyParallax();

        // Sky twinkle + snow + lake
        if(!sky.needsRebuild) drawTwinkle(t);
        if(!snow.needsRebuild) stepSnow(t, dt);
        if(!lake.needsRebuild) drawLake(t);

        // Auto adjustment
        autoAdjustQuality(t);

        // UI stats
        if((perf.frame++ % 12) === 0){
          fpsVal.textContent = String(Math.round(perf.fpsEMA));
          autoVal.textContent = state.qualityMode === 'auto' ? state.autoTier : '—';
          snowVal.textContent = String(snow.targetCount);
        }

        requestAnimationFrame(tick);
      }

      // -----------------------------
      // Init
      // -----------------------------
      function init(){
        // Init UI values
        refreshUI();

        // Pointer parallax
        window.addEventListener('pointermove', onPointerMove, { passive:true });

        // Start with subtle idle motion if no pointer yet
        let idleT = 0;
        const idle = () => {
          if(orientEnabled) return;
          idleT += 0.012;
          // only if user not moving pointer recently (we don't track, keep tiny)
          targetPX = lerp(targetPX, Math.sin(idleT)*0.18, 0.02);
          targetPY = lerp(targetPY, Math.cos(idleT*0.9)*0.12, 0.02);
          targetTX = targetPY;
          targetTY = targetPX;
          requestAnimationFrame(idle);
        };
        requestAnimationFrame(idle);

        // Resize
        window.addEventListener('resize', () => {
          // throttle via rAF
          requestAnimationFrame(resizeAll);
        }, { passive:true });

        resizeAll();

        // Encourage enabling motion on first ENTER click too
        const maybeEnableMotion = () => { tryEnableOrientation(); };
        enterBtn.addEventListener('pointerdown', maybeEnableMotion, { once:true });
        enterBtn2.addEventListener('pointerdown', maybeEnableMotion, { once:true });

        requestAnimationFrame(tick);
      }

      init();
    });
  </script>
</body>
</html>
